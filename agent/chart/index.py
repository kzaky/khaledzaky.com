"""
Chart Lambda — Extracts data points from the draft blog post and renders
Galloway-style SVG charts. Charts are saved to S3 and their paths are
embedded back into the markdown.

Chart style: dark background, bold colors, clean sans-serif type, minimal
decoration. Inspired by profgalloway.com data visualizations.

Uses matplotlib with a custom theme — no AI model needed for chart generation.
Charts are deterministic: same data = same chart every time.
"""

import json
import os
import re
import io
import textwrap

import boto3

s3 = boto3.client("s3")
DRAFTS_BUCKET = os.environ.get("DRAFTS_BUCKET", "")

# Galloway-inspired color palette
COLORS = [
    "#3B82F6",  # blue
    "#F59E0B",  # amber
    "#10B981",  # emerald
    "#EF4444",  # red
    "#8B5CF6",  # violet
    "#EC4899",  # pink
    "#06B6D4",  # cyan
    "#F97316",  # orange
]

BG_COLOR = "#1a1a2e"
TEXT_COLOR = "#e0e0e0"
GRID_COLOR = "#2a2a4a"
FONT_FAMILY = "Inter, -apple-system, BlinkMacSystemFont, sans-serif"


def handler(event, context):
    """
    Input event:
    {
        "title": "...",
        "slug": "...",
        "categories": [...],
        "description": "...",
        "markdown": "complete markdown with <!-- CHART: ... --> placeholders",
        "date": "YYYY-MM-DD",
        "research": "research notes containing data_points section"
    }

    Output: same as input but with chart placeholders replaced by image references,
    plus a "charts" array listing generated chart paths.
    """
    markdown = event.get("markdown", "")
    research = event.get("research", "")
    slug = event.get("slug", "untitled")
    date = event.get("date", "")

    # Find all chart placeholders in the markdown
    chart_pattern = re.compile(r"<!--\s*CHART:\s*(.+?)\s*-->", re.DOTALL)
    chart_matches = chart_pattern.findall(markdown)

    print(f"Found {len(chart_matches)} chart placeholder(s) in markdown")

    # Also extract structured data points from research
    data_points = _extract_data_points(research)
    print(f"Extracted {len(data_points)} data point(s) from research")
    for dp in data_points:
        print(f"  Data point: {dp.get('description', '?')} — values: {dp.get('values', [])} — type: {dp.get('chart_type', '?')}")

    charts_generated = []
    updated_markdown = markdown

    for i, chart_desc in enumerate(chart_matches):
        # Try to find a matching data point from research
        matched_data = _match_data_point(chart_desc, data_points)
        print(f"Chart {i+1}: desc='{chart_desc[:80]}...' — matched={'yes' if matched_data else 'no'}")

        if matched_data:
            chart_filename = f"{slug}-chart-{i + 1}.svg"
            chart_s3_key = f"charts/{date}-{chart_filename}"
            chart_public_path = f"/postimages/charts/{chart_filename}"

            try:
                svg_content = _render_chart(matched_data, chart_desc)

                # Save to S3
                if DRAFTS_BUCKET:
                    s3.put_object(
                        Bucket=DRAFTS_BUCKET,
                        Key=chart_s3_key,
                        Body=svg_content.encode("utf-8"),
                        ContentType="image/svg+xml",
                    )

                # Build markdown replacement
                source = matched_data.get("source", "")
                caption = f"*Source: {source}. Chart generated by blog agent.*" if source else "*Chart generated by blog agent.*"
                replacement = f"![{chart_desc}]({chart_public_path})\n{caption}"

                # Replace the placeholder
                updated_markdown = updated_markdown.replace(
                    f"<!-- CHART: {chart_desc} -->",
                    replacement,
                    1,
                )

                charts_generated.append({
                    "filename": chart_filename,
                    "s3_key": chart_s3_key,
                    "public_path": chart_public_path,
                    "description": chart_desc,
                    "source": source,
                })

            except Exception as e:
                print(f"Failed to generate chart {i + 1}: {e}")
                # Leave placeholder as-is if chart generation fails
        else:
            print(f"Chart {i+1}: no matching data point found — placeholder left as-is")

    # Pass through all original fields plus updates
    result = {k: v for k, v in event.items()}
    result["markdown"] = updated_markdown
    result["charts"] = charts_generated

    return result


def _extract_data_points(research):
    """
    Extract structured data points from research notes.
    Looks for the format:
      - Data point: [description]
      - Values: [label: value, label: value, ...]
      - Source: [citation]
      - Chart type: [bar|line|pie|comparison]
    """
    data_points = []
    current = {}

    for line in research.split("\n"):
        line = line.strip()
        line_lower = line.lower()

        # Support ### headings as data point section markers
        if line_lower.startswith("###") and current.get("description"):
            # A new ### heading after we already have a data point means new section
            if current:
                data_points.append(current)
            current = {}

        if line_lower.startswith("- data point:") or line_lower.startswith("data point:"):
            if current and current.get("description"):
                data_points.append(current)
            current = {"description": line.split(":", 1)[1].strip()}
        elif line_lower.startswith("- values:") or line_lower.startswith("values:"):
            # Values line may have multiple colons (e.g., "Values: 2021: 45%, 2022: 75%")
            # Split only on the FIRST colon after "Values"
            values_str = line.split(":", 1)[1].strip()
            current["values"] = _parse_values(values_str)
        elif line_lower.startswith("- source:") or line_lower.startswith("source:"):
            current["source"] = line.split(":", 1)[1].strip()
        elif line_lower.startswith("- chart type:") or line_lower.startswith("chart type:"):
            current["chart_type"] = line.split(":", 1)[1].strip().lower()

    if current and current.get("description"):
        data_points.append(current)

    return data_points


def _parse_values(values_str):
    """Parse 'label: value, label: value' into list of (label, value) tuples.
    Handles formats like:
      - "Label1: 45%, Label2: 30%"
      - "2021: 45%, 2022: 75%, 2023: 82%"
      - "Manual: 6.5hrs, Automated: 1.8hrs"
      - "60, 40" (bare numbers — labels generated as Item 1, Item 2)
    """
    pairs = []
    # Split on comma followed by optional space — handles both alpha and numeric labels
    for pair in re.split(r",\s*", values_str):
        if ":" in pair:
            label, val = pair.split(":", 1)
            label = label.strip()
            # Strip common suffixes: %, hrs, h, ms, s, x
            val = val.strip()
            val = re.sub(r'(hrs|hr|h|ms|s|x|%|\$)$', '', val, flags=re.IGNORECASE).strip()
            try:
                pairs.append((label, float(val)))
            except ValueError:
                continue
        else:
            # Bare number without a label — try to parse it
            val = pair.strip()
            val = re.sub(r'(hrs|hr|h|ms|s|x|%|\$)$', '', val, flags=re.IGNORECASE).strip()
            try:
                pairs.append((f"Item {len(pairs) + 1}", float(val)))
            except ValueError:
                continue
    return pairs


def _match_data_point(chart_desc, data_points):
    """Find the best matching data point for a chart description."""
    if not data_points:
        return None

    chart_desc_lower = chart_desc.lower()

    # Simple keyword matching — find the data point with the most overlapping words
    best_match = None
    best_score = 0

    for dp in data_points:
        desc_lower = dp.get("description", "").lower()
        # Count overlapping significant words (>3 chars)
        desc_words = set(w for w in chart_desc_lower.split() if len(w) > 3)
        dp_words = set(w for w in desc_lower.split() if len(w) > 3)
        score = len(desc_words & dp_words)
        if score > best_score and dp.get("values"):
            best_score = score
            best_match = dp

    # Return best match if we have at least 1 overlapping word
    return best_match if best_score >= 1 else (data_points[0] if data_points and data_points[0].get("values") else None)


def _render_chart(data_point, title):
    """
    Render a Galloway-style SVG chart. Pure SVG generation — no matplotlib needed.
    This keeps the Lambda lightweight with zero dependencies.
    """
    values = data_point.get("values", [])
    chart_type = data_point.get("chart_type", "bar")

    if not values:
        return ""

    if chart_type == "pie":
        return _render_pie_chart(values, title)
    else:
        return _render_bar_chart(values, title)


def _render_bar_chart(values, title):
    """Render a horizontal bar chart as SVG."""
    max_val = max(v for _, v in values)
    num_bars = len(values)

    # Dimensions
    margin_left = 160
    margin_right = 60
    margin_top = 60
    margin_bottom = 30
    bar_height = 36
    bar_gap = 12
    chart_height = margin_top + (bar_height + bar_gap) * num_bars + margin_bottom
    chart_width = 600
    bar_area_width = chart_width - margin_left - margin_right

    svg_parts = [
        f'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {chart_width} {chart_height}" '
        f'font-family="{FONT_FAMILY}">',
        f'<rect width="{chart_width}" height="{chart_height}" fill="{BG_COLOR}" rx="8"/>',
        # Title
        f'<text x="{chart_width // 2}" y="35" text-anchor="middle" '
        f'fill="{TEXT_COLOR}" font-size="15" font-weight="600">'
        f'{_escape_xml(textwrap.shorten(title, width=70))}</text>',
    ]

    for i, (label, val) in enumerate(values):
        y = margin_top + i * (bar_height + bar_gap)
        bar_width = (val / max_val) * bar_area_width if max_val > 0 else 0
        color = COLORS[i % len(COLORS)]

        # Label
        svg_parts.append(
            f'<text x="{margin_left - 10}" y="{y + bar_height // 2 + 5}" '
            f'text-anchor="end" fill="{TEXT_COLOR}" font-size="12">'
            f'{_escape_xml(textwrap.shorten(label, width=20))}</text>'
        )

        # Bar
        svg_parts.append(
            f'<rect x="{margin_left}" y="{y}" width="{bar_width:.1f}" '
            f'height="{bar_height}" fill="{color}" rx="4" opacity="0.9"/>'
        )

        # Value label
        display_val = f"{val:.0f}" if val == int(val) else f"{val:.1f}"
        svg_parts.append(
            f'<text x="{margin_left + bar_width + 8}" y="{y + bar_height // 2 + 5}" '
            f'fill="{TEXT_COLOR}" font-size="12" font-weight="600">{display_val}</text>'
        )

    svg_parts.append("</svg>")
    return "\n".join(svg_parts)


def _render_pie_chart(values, title):
    """Render a pie/donut chart as SVG."""
    total = sum(v for _, v in values)
    if total == 0:
        return ""

    chart_size = 400
    cx, cy = chart_size // 2, chart_size // 2 + 20
    radius = 120
    inner_radius = 60  # donut style

    svg_parts = [
        f'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 {chart_size} {chart_size + 80}" '
        f'font-family="{FONT_FAMILY}">',
        f'<rect width="{chart_size}" height="{chart_size + 80}" fill="{BG_COLOR}" rx="8"/>',
        f'<text x="{chart_size // 2}" y="35" text-anchor="middle" '
        f'fill="{TEXT_COLOR}" font-size="15" font-weight="600">'
        f'{_escape_xml(textwrap.shorten(title, width=50))}</text>',
    ]

    import math
    start_angle = -90  # Start from top

    for i, (label, val) in enumerate(values):
        pct = val / total
        end_angle = start_angle + pct * 360
        color = COLORS[i % len(COLORS)]

        # Convert to radians for path calculation
        start_rad = math.radians(start_angle)
        end_rad = math.radians(end_angle)

        # Outer arc
        x1 = cx + radius * math.cos(start_rad)
        y1 = cy + radius * math.sin(start_rad)
        x2 = cx + radius * math.cos(end_rad)
        y2 = cy + radius * math.sin(end_rad)

        # Inner arc
        ix1 = cx + inner_radius * math.cos(end_rad)
        iy1 = cy + inner_radius * math.sin(end_rad)
        ix2 = cx + inner_radius * math.cos(start_rad)
        iy2 = cy + inner_radius * math.sin(start_rad)

        large_arc = 1 if pct > 0.5 else 0

        path = (
            f"M {x1:.1f} {y1:.1f} "
            f"A {radius} {radius} 0 {large_arc} 1 {x2:.1f} {y2:.1f} "
            f"L {ix1:.1f} {iy1:.1f} "
            f"A {inner_radius} {inner_radius} 0 {large_arc} 0 {ix2:.1f} {iy2:.1f} Z"
        )

        svg_parts.append(f'<path d="{path}" fill="{color}" opacity="0.9"/>')
        start_angle = end_angle

    # Legend
    legend_y = cy + radius + 30
    for i, (label, val) in enumerate(values):
        pct = (val / total) * 100
        lx = 40 + (i % 2) * (chart_size // 2)
        ly = legend_y + (i // 2) * 22
        color = COLORS[i % len(COLORS)]

        svg_parts.append(f'<rect x="{lx}" y="{ly - 8}" width="10" height="10" fill="{color}" rx="2"/>')
        svg_parts.append(
            f'<text x="{lx + 16}" y="{ly}" fill="{TEXT_COLOR}" font-size="11">'
            f'{_escape_xml(label)} ({pct:.0f}%)</text>'
        )

    svg_parts.append("</svg>")
    return "\n".join(svg_parts)


def _escape_xml(text):
    """Escape special XML characters."""
    return (
        text.replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
        .replace("'", "&apos;")
    )
