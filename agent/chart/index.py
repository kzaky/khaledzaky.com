"""
Chart Lambda — Extracts data points from the draft blog post and renders
SVG charts and conceptual diagrams. Charts are saved to S3 and their paths
are embedded back into the markdown.

Renderers are in the `renderers/` package — each chart/diagram type has its
own module for readability and testability.

Charts are deterministic: same data = same chart every time.
"""

import logging
import os
import re

import boto3

from renderers import _escape_xml
from renderers.bar import render_bar_chart
from renderers.pie import render_pie_chart
from renderers.comparison import render_comparison_diagram
from renderers.progression import render_progression_diagram
from renderers.stack import render_stack_diagram
from renderers.convergence import render_convergence_diagram
from renderers.venn import render_venn_diagram

logger = logging.getLogger()
logger.setLevel(logging.INFO)

s3 = boto3.client("s3")
DRAFTS_BUCKET = os.environ.get("DRAFTS_BUCKET", "")


def handler(event, context):
    """
    Input event:
    {
        "title": "...",
        "slug": "...",
        "categories": [...],
        "description": "...",
        "markdown": "complete markdown with <!-- CHART: ... --> placeholders",
        "date": "YYYY-MM-DD",
        "research": "research notes containing data_points section"
    }

    Output: same as input but with chart placeholders replaced by image references,
    plus a "charts" array listing generated chart paths.
    """
    markdown = event.get("markdown", "")
    research = event.get("research", "")
    slug = event.get("slug", "untitled")
    date = event.get("date", "")

    # Find all chart placeholders in the markdown
    chart_pattern = re.compile(r"<!--\s*CHART:\s*(.+?)\s*-->", re.DOTALL)
    chart_matches = chart_pattern.findall(markdown)

    # Find all diagram placeholders in the markdown
    diagram_pattern = re.compile(r"<!--\s*DIAGRAM:\s*(.+?)\s*-->", re.DOTALL)
    diagram_matches = diagram_pattern.findall(markdown)

    logger.info("Found %d chart placeholder(s) and %d diagram placeholder(s) in markdown", len(chart_matches), len(diagram_matches))

    # Also extract structured data points from research
    data_points = _extract_data_points(research)
    logger.info("Extracted %d data point(s) from research", len(data_points))
    for dp in data_points:
        logger.info("  Data point: %s — values: %s — type: %s", dp.get('description', '?'), dp.get('values', []), dp.get('chart_type', '?'))

    charts_generated = []
    updated_markdown = markdown

    # --- Process chart placeholders (numeric data) ---
    for i, chart_desc in enumerate(chart_matches):
        matched_data = _match_data_point(chart_desc, data_points)
        logger.info("Chart %d: desc='%s...' — matched=%s", i+1, chart_desc[:80], 'yes' if matched_data else 'no')

        if matched_data:
            chart_filename = f"{slug}-chart-{i + 1}.svg"
            chart_s3_key = f"charts/{date}-{chart_filename}"
            chart_public_path = f"/postimages/charts/{chart_filename}"

            try:
                svg_content = _render_chart(matched_data, chart_desc)

                if DRAFTS_BUCKET:
                    s3.put_object(
                        Bucket=DRAFTS_BUCKET,
                        Key=chart_s3_key,
                        Body=svg_content.encode("utf-8"),
                        ContentType="image/svg+xml",
                    )

                source = matched_data.get("source", "")
                caption = f"*Source: {source}. Chart generated by blog agent.*" if source else "*Chart generated by blog agent.*"
                replacement = f"![{chart_desc}]({chart_public_path})\n{caption}"

                updated_markdown = updated_markdown.replace(
                    f"<!-- CHART: {chart_desc} -->",
                    replacement,
                    1,
                )

                charts_generated.append({
                    "filename": chart_filename,
                    "s3_key": chart_s3_key,
                    "public_path": chart_public_path,
                    "description": chart_desc,
                    "source": source,
                })

            except Exception as e:
                logger.error("Failed to generate chart %d: %s", i + 1, e)
        else:
            logger.info("Chart %d: no matching data point found — placeholder left as-is", i+1)

    # --- Process diagram placeholders (conceptual visuals) ---
    for i, diagram_spec in enumerate(diagram_matches):
        diagram_filename = f"{slug}-diagram-{i + 1}.svg"
        diagram_s3_key = f"charts/{date}-{diagram_filename}"
        diagram_public_path = f"/postimages/charts/{diagram_filename}"

        try:
            svg_content = _render_diagram(diagram_spec)
            if not svg_content:
                logger.info("Diagram %d: could not parse spec — skipping", i+1)
                continue

            if DRAFTS_BUCKET:
                s3.put_object(
                    Bucket=DRAFTS_BUCKET,
                    Key=diagram_s3_key,
                    Body=svg_content.encode("utf-8"),
                    ContentType="image/svg+xml",
                )

            # Build alt text from the spec's first field (type) and second field (title/header)
            parts = [p.strip() for p in diagram_spec.split("|")]
            alt_text = parts[1] if len(parts) > 1 else "Diagram"
            replacement = f"![{_escape_xml(alt_text)}]({diagram_public_path})"

            updated_markdown = updated_markdown.replace(
                f"<!-- DIAGRAM: {diagram_spec} -->",
                replacement,
                1,
            )

            charts_generated.append({
                "filename": diagram_filename,
                "s3_key": diagram_s3_key,
                "public_path": diagram_public_path,
                "description": alt_text,
                "type": "diagram",
            })
            logger.info("Diagram %d: rendered %s diagram — %s", i+1, parts[0] if parts else '?', diagram_filename)

        except Exception as e:
            logger.error("Failed to generate diagram %d: %s", i + 1, e)

    # Pass through all original fields plus updates
    result = {k: v for k, v in event.items()}
    result["markdown"] = updated_markdown
    result["charts"] = charts_generated

    return result


def _extract_data_points(research):
    """
    Extract structured data points from research notes.
    Looks for the format:
      - Data point: [description]
      - Values: [label: value, label: value, ...]
      - Source: [citation]
      - Chart type: [bar|line|pie|comparison]
    """
    data_points = []
    current = {}

    for line in research.split("\n"):
        line = line.strip()
        line_lower = line.lower()

        # Support ### headings as data point section markers
        if line_lower.startswith("###") and current.get("description"):
            # A new ### heading after we already have a data point means new section
            if current:
                data_points.append(current)
            current = {}

        if line_lower.startswith("- data point:") or line_lower.startswith("data point:"):
            if current and current.get("description"):
                data_points.append(current)
            current = {"description": line.split(":", 1)[1].strip()}
        elif line_lower.startswith("- values:") or line_lower.startswith("values:"):
            # Values line may have multiple colons (e.g., "Values: 2021: 45%, 2022: 75%")
            # Split only on the FIRST colon after "Values"
            values_str = line.split(":", 1)[1].strip()
            current["values"] = _parse_values(values_str)
        elif line_lower.startswith("- source:") or line_lower.startswith("source:"):
            current["source"] = line.split(":", 1)[1].strip()
        elif line_lower.startswith("- chart type:") or line_lower.startswith("chart type:"):
            current["chart_type"] = line.split(":", 1)[1].strip().lower()

    if current and current.get("description"):
        data_points.append(current)

    return data_points


def _parse_values(values_str):
    """Parse 'label: value, label: value' into list of (label, value) tuples.
    Handles formats like:
      - "Label1: 45%, Label2: 30%"
      - "2021: 45%, 2022: 75%, 2023: 82%"
      - "Manual: 6.5hrs, Automated: 1.8hrs"
      - "60, 40" (bare numbers — labels generated as Item 1, Item 2)
    """
    pairs = []
    # Split on comma followed by optional space — handles both alpha and numeric labels
    for pair in re.split(r",\s*", values_str):
        if ":" in pair:
            label, val = pair.split(":", 1)
            label = label.strip()
            # Strip common suffixes: %, hrs, h, ms, s, x
            val = val.strip()
            val = re.sub(r'(hrs|hr|h|ms|s|x|%|\$)$', '', val, flags=re.IGNORECASE).strip()
            try:
                pairs.append((label, float(val)))
            except ValueError:
                continue
        else:
            # Bare number without a label — try to parse it
            val = pair.strip()
            val = re.sub(r'(hrs|hr|h|ms|s|x|%|\$)$', '', val, flags=re.IGNORECASE).strip()
            try:
                pairs.append((f"Item {len(pairs) + 1}", float(val)))
            except ValueError:
                continue
    return pairs


def _match_data_point(chart_desc, data_points):
    """Find the best matching data point for a chart description."""
    if not data_points:
        return None

    chart_desc_lower = chart_desc.lower()

    # Simple keyword matching — find the data point with the most overlapping words
    best_match = None
    best_score = 0

    for dp in data_points:
        desc_lower = dp.get("description", "").lower()
        # Count overlapping significant words (>3 chars)
        desc_words = set(w for w in chart_desc_lower.split() if len(w) > 3)
        dp_words = set(w for w in desc_lower.split() if len(w) > 3)
        score = len(desc_words & dp_words)
        if score > best_score and dp.get("values"):
            best_score = score
            best_match = dp

    # Return best match if we have at least 1 overlapping word
    return best_match if best_score >= 1 else (data_points[0] if data_points and data_points[0].get("values") else None)


def _render_chart(data_point, title):
    """Dispatch to the correct chart renderer based on chart_type."""
    values = data_point.get("values", [])
    chart_type = data_point.get("chart_type", "bar")

    if not values:
        return ""

    if chart_type == "pie":
        return render_pie_chart(values, title)
    else:
        return render_bar_chart(values, title)


def _render_diagram(spec_str):
    """Parse a diagram spec string and dispatch to the correct renderer.
    Spec format: 'type | field1 | field2 | ...'
    """
    parts = [p.strip() for p in spec_str.split("|")]
    if len(parts) < 2:
        return None

    diagram_type = parts[0].lower()
    fields = parts[1:]

    diagram_renderers = {
        "comparison": render_comparison_diagram,
        "progression": render_progression_diagram,
        "stack": render_stack_diagram,
        "convergence": render_convergence_diagram,
        "venn": render_venn_diagram,
    }

    renderer = diagram_renderers.get(diagram_type)
    if not renderer:
        logger.warning("Unknown diagram type: %s", diagram_type)
        return None

    return renderer(fields)
